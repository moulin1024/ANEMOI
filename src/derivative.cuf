module derivative
    use precision
    use dimen
    contains
    !---------------------------------------------------------------------------
    ! This module compute the derivative of the flow field
    !---------------------------------------------------------------------------
    ! contains subroutine:
    ! - ddxy
    !---------------------------------------------------------------------------

subroutine ddxy(dfdi,f,axis,t,plan)
    !---------------------------------------------------------------------------
    ! declaration
    !---------------------------------------------------------------------------
    use cufft_m 
    use cudafor
    implicit none
    ! Input: velocity field
    real(fp), dimension(nx,ny,nz2),intent(inout),device :: f,dfdi
    integer axis
    complex(fp), dimension(:,:,:),allocatable,device :: f_hat,dfdi_hat
    ! fft plan
    type(c_ptr)  :: plan(2)
    integer :: istat,k,t

    save f_hat,dfdi_hat
    !---------------------------------------------------------------------------
    ! main code
    !---------------------------------------------------------------------------
    !---------------------------------------------------------------------------
    ! init
    if (t.eq.1) then
        allocate(f_hat(nx/2+1,ny,nz2,3))
        allocate(dfdi_hat(nx/2+1,ny,nz2,3))
    endif

    !---------------------------------------------------------------------------
    ! Forward fft
    call cufftExec(plan(1),f,f_hat)

    !---------------------------------------------------------------------------
    ! Computing x derivatives or y derivative
    if (axis == 1) then         ! dfdx
        call spec_deriv_x<<<grid, tBlock>>>(f_hat,dfdi_hat)
    else if (axis == 2) then    ! dfdy
        call spec_deriv_y<<<grid, tBlock>>>(f_hat,dfdi_hat)
    end if
    !---------------------------------------------------------------------------
    ! Backward fft
    call  cufftExec(plan(2),dfdi_hat,dfdi(:,:,2:nzb+1))
end subroutine ddxy

attributes(global) subroutine spec_deriv_x(f_hat,dfdi_hat,axis)
    implicit none
    complex(fp), dimension(nx/2+1,ny,nzb),intent(inout) :: f_hat,dfdi_hat
    integer,value :: axis
    integer :: i,j,k,ii,jj
    i = (blockIdx%x - 1) * blockDim%x + threadIdx%x;
    j = (blockIdx%y - 1) * blockDim%y + threadIdx%y;
    k = (blockIdx%z - 1) * blockDim%z + threadIdx%z;

    if (i <= nx/2+1) then
        f_hat(i,j,k) = f_hat(i,j,k)*inxny
        ! Shift wave number
        ii = i - 1
        jj = j - 1
        if(jj.gt.nint(ny/2.)) jj=jj-ny
        jj = jj*l_r
        
        !---------------------------------------------------------------------------
        ! Compute spectral derivative
        if (axis == 1) then         ! dfdx
            dfdi_hat(i,j,k) = dcmplx(aimag(-f_hat(i,j,k)),dble(f_hat(i,j,k)))*ii
        else if (axis == 2) then    ! dfdy
            dfdi_hat(i,j,k) = dcmplx(aimag(-f_hat(i,j,k)),dble(f_hat(i,j,k)))*jj
        end if

        ! !---------------------------------------------------------------------------
        ! ! Cut nyquist frequency (do we need it?)
        if (j == ny/2+1 .or. i == nx/2+1)then
            dfdi_hat(i,j,k) = dcmplx(0._fp)
        end if
        
    end if
        
end subroutine spec_deriv_xy

attributes(global) subroutine ddz_uv (dfdz,f)
    !---------------------------------------------------------------------------
    ! declaration
    !---------------------------------------------------------------------------
    implicit none
    real(fp), dimension(nx,ny,nz2,3), intent(out) :: dfdz
    real(fp), dimension(nx,ny,nz2,3), intent(in) :: f
    integer :: i,j,k

    i = (blockIdx%x - 1) * blockDim%x + threadIdx%x
    j = (blockIdx%y - 1) * blockDim%y + threadIdx%y
    k = (blockIdx%z - 1) * blockDim%z + threadIdx%z
    !---------------------------------------------------------------------------
    ! main code
    !---------------------------------------------------------------------------
    if (k>1 .and. k<nz2) then
            dfdz(i,j,k,1)=(f(i,j,k,1)-f(i,j,k-1,1))*idz
            dfdz(i,j,k,2)=(f(i,j,k,2)-f(i,j,k-1,2))*idz
            dfdz(i,j,k,3)=(f(i,j,k+1,3)-f(i,j,k,3))*idz
    end if
end subroutine ddz_uv

attributes(global) subroutine ddz_w (dfdz,f)
    !---------------------------------------------------------------------------
    ! declaration
    !---------------------------------------------------------------------------
    implicit none
    real(fp), dimension(nx,ny,nz2,3), intent(out) :: dfdz
    real(fp), dimension(nx,ny,nz2,3), intent(in) :: f
    integer :: i,j,k

    i = (blockIdx%x - 1) * blockDim%x + threadIdx%x
    j = (blockIdx%y - 1) * blockDim%y + threadIdx%y
    k = (blockIdx%z - 1) * blockDim%z + threadIdx%z
    !---------------------------------------------------------------------------
    ! main code
    !---------------------------------------------------------------------------
    if (k>1 .and. k<nz2) then

            dfdz(i,j,k,1)=(f(i,j,k+1,1)-f(i,j,k,1))*idz
            dfdz(i,j,k,2)=(f(i,j,k+1,2)-f(i,j,k,2))*idz
            dfdz(i,j,k,3)=(f(i,j,k,3)-f(i,j,k-1,3))*idz
    end if
end subroutine ddz_w

end module derivative

    
