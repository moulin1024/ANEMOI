module divergence
use precision
use dimen
contains

subroutine divstress(div_tau_vec,tau,plan)
    ! divtx,txx,txy,txz

    !---------------------------------------------------------------------------
    ! declaration
    !---------------------------------------------------------------------------
    use cudafor
    use derivative
    implicit none
    integer :: i,j,k
    real(fp),dimension(nx,ny,nz2,3),intent(out),device:: div_tau_vec
    real(fp),dimension(nx,ny,nz2,6),intent(in),device:: tau
    real(fp),dimension(:,:,:,:),allocatable,device:: tau_vec
    real(fp),dimension(:,:,:),allocatable,device:: tdx,tdy,tdz
    
    real(fp),dimension(nx,ny,nz2):: tdx_host,tdy_host,tdz_host
    type(c_ptr),intent(in) :: plan(2)
    ! Cuda variable
    type(dim3) :: grid, tBlock
    grid = dim3(nx/16,ny/16,nz2/2)
    tBlock = dim3(16,16,2)

    integer stat_flag = 1
    save tau_vec,tdx,tdy,tdz
    !---------------------------------------------------------------------------
    ! main code
    !---------------------------------------------------------------------------
    if (stat_flag /= 0) then
        allocate(tdx(nx,ny,nz2,3),STAT=stat_flag)
        allocate(tdy(nx,ny,nz2,3),STAT=stat_flag)
        allocate(tdz(nx,ny,nz2,3),STAT=stat_flag)
        allocate(tau_vec(nx,ny,nz2,3),STAT=stat_flag)
    end if 
    !---------------------------------------------------------------------------
    ! stress gradients
    ! txx,tyx,tzx
    tau_vec = tau(:,:,:,1:3)
    call ddxy(tdx,tau_vec,1,plan)
    ! txy,tyy,tzy
    tau_vec(:,:,:,1) = tau(:,:,:,2)
    tau_vec(:,:,:,2) = tau(:,:,:,4)
    tau_vec(:,:,:,3) = tau(:,:,:,5)
    call ddxy(tdy,tau_vec,2,plan)

    tau_vec(:,:,:,1) = tau(:,:,:,3)
    tau_vec(:,:,:,2) = tau(:,:,:,5)
    tau_vec(:,:,:,3) = tau(:,:,:,6)
    call ddz_w<<<grid, tBlock>>>(tdz,tau_vec)
    !---------------------------------------------------------------------------
    ! stress divergence
    
    call div_sum<<<grid, tBlock>>>(divt,tdx,tdy,tdz)
    ! stop
end subroutine divstress

attributes(global) subroutine div_sum(divt,tdx,tdy,tdz)

    !---------------------------------------------------------------------------
    ! declaration
    !---------------------------------------------------------------------------

    implicit none

    real(fp), dimension(nx,ny,nz2), intent(out) :: divt
    real(fp), dimension(nx,ny,nz2), intent(in) :: tdx,tdy,tdz

    integer :: i,j,k

    i = (blockIdx%x - 1) * blockDim%x + threadIdx%x
    j = (blockIdx%y - 1) * blockDim%y + threadIdx%y
    k = (blockIdx%z - 1) * blockDim%z + threadIdx%z
    ! print *,i
    !---------------------------------------------------------------------------
    ! main code
    !---------------------------------------------------------------------------
    ! do k=2,nzb+1
    if (k>1 .and. k<nz2) divt(i,j,k)=tdx(i,j,k)+tdy(i,j,k)+tdz(i,j,k)
    ! end do

end subroutine div_sum

attributes(global) subroutine div_p(rhs_p,dudx,dvdy,dwdz)

    !---------------------------------------------------------------------------
    ! declaration
    !---------------------------------------------------------------------------

    implicit none

    real(fp), dimension(nx,ny,nz2), intent(out) :: rhs_p
    real(fp), dimension(nx,ny,nz2), intent(in) :: dudx,dvdy,dwdz

    integer :: i,j,k

    i = (blockIdx%x - 1) * blockDim%x + threadIdx%x
    j = (blockIdx%y - 1) * blockDim%y + threadIdx%y
    k = (blockIdx%z - 1) * blockDim%z + threadIdx%z
    ! print *,i
    !---------------------------------------------------------------------------
    ! main code
    !---------------------------------------------------------------------------
    ! do k=2,nzb+1
    if (k>1 .and. k<nz2) rhs_p(i,j,k)=(dudx(i,j,k)+dvdy(i,j,k)+dwdz(i,j,k))/dt
    ! end do

end subroutine div_p

end module divergence