gitmodule pressure

    use precision
    use dimen
    ! Pressure solver
    integer npsx,npsy,ni,nj,lsize
    parameter(npsx=1, npsy=nz/(nz2-2))
    parameter(ni=(nx/2+1)/npsx, nj=ny/npsy)
    parameter(lsize=(nx/2+1)*nj*nzb)
    contains
    
    subroutine pressure_poisson(p,rhs_p,dpdx,dpdy,me,nall,t,plan)
    
        !---------------------------------------------------------------------------
        ! declaration
        !---------------------------------------------------------------------------
        use cudafor
        use cufft_m
        implicit none
    
        integer,intent(in) :: t,me,nall
        real(fp),dimension(nx,ny,nz2),intent(in),device:: rhs_p
        real(fp),dimension(nx,ny,nz2),intent(inout),device:: p,dpdx,dpdy
        real(fp),dimension(nx,ny,nz2),device:: p_test
        complex(fp), dimension(:,:,:),allocatable,device:: h_x,h_2,h_3
        complex(fp), dimension(:,:,:),allocatable,device:: dpdx_hat,dpdy_hat
        
        integer i_global,j_global
        integer i,j,k,ii,jj,size,istat,REQUEST
        type(c_ptr) plan(2)
       
        ! Cuda variable
        type(dim3) :: grid, tBlock, grid1,tBlock1, grid_3d,tBlock_3d
        grid= dim3(int((nx/2+1)/32)+1,ny,1)
        tBlock= dim3(32,1,1)
        tBlock1 = dim3(32,1,1)
        grid1 = dim3(int((nx/2+1)/32)+1,nj,1) ! Notice the difference between nj and ny
    
        tBlock_3d = dim3(32,1,1)
        grid_3d = dim3(int((nx/2+1)/32)+1,ny,nzb) ! Notice the difference between nzb and nz2
    
        
        save h_x,h_2,h_3,dpdx_hat,dpdy_hat
    
    
        !---------------------------------------------------------------------------
        ! main code
        !---------------------------------------------------------------------------
        !---------------------------------------------------------------------------
        ! init
        if(t.eq.1)then
            ! Allocate internal variable
            allocate(h_x(nx/2+1,ny,nzb))
            allocate(dpdx_hat(nx/2+1,ny,nzb))
            allocate(dpdy_hat(nx/2+1,ny,nzb))
            allocate(h_2(nx/2+1,nj,nz))
            allocate(h_3(nx/2+1,nj,nz))
        endif
        !---------------------------------------------------------------------------
        ! compute forward fft interior
        call cufftExec(plan(1),rhs_p(:,:,2:nzb+1),h_x)
    
        ! if (nzb + 2 == nz2 ) then
        ! ! ---------------------------------------------------------------------------
        ! ! solve tri-diag matrix directly, if there is only 1 GPU
        !     call solve_tridiag<<<grid, tBlock>>>(h_x,me)
        ! else 
        !---------------------------------------------------------------------------
        ! redistribute mpi
            call slab_transpose_z2y<<<grid1, tBlock1>>>(h_x,h_3)
            if (fp==singlePrecision) then 
                call mpi_ialltoall(h_3(1,1,1),lsize,mpi_complex, &
                h_2(1,1,1),lsize,mpi_complex,nall,REQUEST,ierr)
            else
                call mpi_ialltoall(h_3(1,1,1),lsize,mpi_double_complex, &
                h_2(1,1,1),lsize,mpi_double_complex,nall,REQUEST,ierr)
            end if

            call mpi_wait(REQUEST,STATUS2, IERR)
    
        !---------------------------------------------------------------------------
        ! solve tri-diag matrix
            call solve_tridiag<<<grid1, tBlock1>>>(h_2,me)
    
    
        !-------------------------------------------------------------------------
        ! redistribute mpi
            if (fp==singlePrecision) then 
                call mpi_ialltoall(h_2(1,1,1),lsize,mpi_complex, &
                    h_3(1,1,1),lsize,mpi_complex,nall,REQUEST,ierr)
            else 
                call mpi_ialltoall(h_2(1,1,1),lsize,mpi_double_complex, &
                    h_3(1,1,1),lsize,mpi_double_complex,nall,REQUEST,ierr)
            end if

            call mpi_wait(REQUEST,STATUS2, IERR)
            call slab_transpose_y2z<<<grid1, tBlock1>>>(h_3,h_x)
        end if
        !-------------------------------------------------------------------------
        ! compute p_hat (i.e h_z), dpdx_hat, dpdy_hat
        ! x
        call press_grad<<<grid_3d, tBlock_3d>>>(h_x,dpdx_hat,dpdy_hat)
        call cufftExec(plan(2),dpdx_hat,dpdx(:,:,2:nzb+1))
        call cufftExec(plan(2),dpdy_hat,dpdy(:,:,2:nzb+1))
        call cufftExec(plan(2),h_x,p(:,:,2:nzb+1))
    end subroutine pressure_poisson
    
    attributes(global) subroutine slab_transpose_z2y(h_x,h_3)
        ! Transpose z slab to y slab
        implicit none
        complex(fp), dimension(nx/2+1,ny,nzb),intent(in) :: h_x
        complex(fp), dimension(nx/2+1,nj,nz),intent(inout) :: h_3
        integer :: i,j,k,i_block,j_block
    
        i = (blockIdx%x - 1) * blockDim%x + threadIdx%x;
        j = (blockIdx%y - 1) * blockDim%y + threadIdx%y;
    
        if (i<=nx/2+1) then
            do j_block=1,npsy
                h_3(i,j,(j_block-1)*nzb+1:j_block*nzb)= h_x(i,j+(j_block-1)*nj,:)
            end do
        end if
    end subroutine
    
    attributes(global) subroutine slab_transpose_y2z(h_3,h_x)
        ! Transpose y slab to z slab
        implicit none
        complex(fp), dimension(nx/2+1,ny,nzb),intent(inout) :: h_x
        complex(fp), dimension(nx/2+1,nj,nz),intent(in) :: h_3
        integer :: i,j,k,i_block,j_block
    
        i = (blockIdx%x - 1) * blockDim%x + threadIdx%x;
        j = (blockIdx%y - 1) * blockDim%y + threadIdx%y;
    
        if (i<=nx/2+1) then
            do j_block=1,npsy
                h_x(i,j+(j_block-1)*nj,:) = h_3(i,j,(j_block-1)*nzb+1:j_block*nzb)
            end do
        end if
    end subroutine
    
    attributes(global) subroutine solve_tridiag(h_2,device_id)
        ! Solve tridiag system
        implicit none
        complex(fp), dimension(nx/2+1,nj,nz),intent(inout) :: h_2
        complex(fp),dimension(nz+1) :: rhs_col_cmplx,p_col_cmplx
        integer :: i,j,k,i_global,j_global,ii,jj
        integer,value,intent(in) :: device_id
    
        i = (blockIdx%x - 1) * blockDim%x + threadIdx%x;
        j = (blockIdx%y - 1) * blockDim%y + threadIdx%y;
    
        if (i<=nx/2+1) then
            j_global = j + device_id*nj
            jj = j_global - 1
            i_global=i! + (mei-1)*ni
            ii=i_global-1
            if(jj.gt.(ny/2)) jj=jj-ny
            jj=jj*l_r
            ! Form the rhs of the pressure equation
            rhs_col_cmplx(1)=0._fp          
            rhs_col_cmplx(2:nz)=h_2(i,j,1:nz-1)
            rhs_col_cmplx(nz+1)=0._fp
            ! Tridiag solver
            call tridiag(rhs_col_cmplx,p_col_cmplx,ii,jj)
            ! Apply the fft scaling factor
            h_2(i,j,1:nz) = p_col_cmplx(2:nz+1)*inxny
        end if
    end subroutine
    
    attributes(device) subroutine tridiag(r,u,ii,jj)
        implicit none
        INTEGER ii,jj,k
        complex(fp),intent(in) :: r(nz+1)
        complex(fp),intent(out) :: u(nz+1)
        real(fp) :: gam(nz+1)
        real(fp) :: a,b,c,c_bottom(3),c_inner(3),c_top(3),bet

        if ((ii.eq.0).and.(jj.eq.0)) then
            c_bottom(1) = 0._fp
            c_bottom(2) = 1._fp
            c_bottom(3) = 0._fp
        else
            c_bottom(1) = 0._fp
            c_bottom(2) = -1._fp
            c_bottom(3) = 1._fp
        end if

        c_inner(1) = 1.0/(dz**2)
        c_inner(2) = (-ii*ii-jj*jj-2.0/(dz**2))
        c_inner(3) = 1.0/(dz**2)

        c_top(1) = -1._fp
        c_top(2) = 1._fp
        c_top(3) = 0._fp
        
        bet=c_bottom(2)
        u(1)=r(1)/bet

        do k=2,nz+1
            if (k == 2) then
                c = c_bottom(3)
            else 
                c = c_inner(3)
            end if

            if (k == nz+1) then
                a = c_top(1)
                b = c_top(2)
            else 
                a = c_inner(1)
                b = c_inner(2)
            end if          

            gam(k)=c/bet
            bet=b-a*gam(k)
            u(k)=(r(k)-a*u(k-1))/bet
        end do

        do k=nz,1,-1
            u(k)=u(k)-gam(k+1)*u(k+1)
        end do
    end subroutine
    
    attributes(global) subroutine press_grad(f_hat,dfdx_hat,dfdy_hat)
        implicit none
        real(fp),dimension(nz2) :: a,b,c
        complex(fp), dimension(nx/2+1,ny,nzb),intent(inout) :: f_hat
        complex(fp), dimension(nx/2+1,ny,nzb),intent(inout) :: dfdx_hat,dfdy_hat
        integer :: i,j,k,ii,jj
        i = (blockIdx%x - 1) * blockDim%x + threadIdx%x;
        j = (blockIdx%y - 1) * blockDim%y + threadIdx%y;
        k = (blockIdx%z - 1) * blockDim%z + threadIdx%z  !+ 1 !(Watch out! no + 1 here!)
        if (i <= nx/2+1) then
            ! ! Shift wave number
            ii = i - 1
            jj = j - 1
            if(jj.gt.nint(ny/2.)) jj=jj-ny
            jj=jj*l_r
    
            if (abs(jj) >= nint(l_r*ny/2.0).or. ii >= nint(nx/2.0)) then
                f_hat(i,j,k)=dcmplx(0._fp)
            end if
            !  ! dfdx_hat
            dfdx_hat(i,j,k)=dcmplx(aimag(f_hat(i,j,k))*(-1.0), &
                real(f_hat(i,j,k)))*ii
            ! ! dfdy_hat
            dfdy_hat(i,j,k)=dcmplx(aimag(f_hat(i,j,k))*(-1.0), &
                real(f_hat(i,j,k)))*jj
    
        end if
    end subroutine press_grad
    
    attributes(global) subroutine velo_corr(u,dpdi)
        implicit none
        real(fp), dimension(nx,ny,nz2),intent(inout) :: u
        real(fp), dimension(nx,ny,nz2),intent(in) :: dpdi
        integer :: i,j,k
        i = (blockIdx%x - 1) * blockDim%x + threadIdx%x;
        j = (blockIdx%y - 1) * blockDim%y + threadIdx%y;
        k = (blockIdx%z - 1) * blockDim%z + threadIdx%z;
    
        if (k>1 .and. k<nz2) u(i,j,k)= u(i,j,k) - dpdi(i,j,k)*dt
        
    end subroutine velo_corr
    
    
    end module pressure
    