module turbine
    !===============================================================================
    ! compute turbine
    !===============================================================================
    ! warning: 
    !   -   chord and twist are hardcoded for wire01 
    !   -   wind turbine force is completed immersed within 1 GPU
    !       thus only used in device_id = 0
    ! ---------------------------------------------------------------------------
    ! Left-hand coordinate system ():
    ! Top-down view:          Front-back view:
    !                              Z
    !         | /                 -|-
    !         |/               /   | / \
    !         Z_ _ _ _ X      |    X--  |--Y, 
    !        /|                \   |   /
    !       / |                   -|- 
    !         |                    |           
    !         Y
    ! counter-clockwise for positive gamma and phi angle from y axis
    ! ---------------------------------------------------------------------------
    ! Staggering grid:        
    !    --w-----w-- --w--          
    !   |  u  |  u  |  u  |         
    !   |--w- |--w--|--w--|  
    !   |  u  |  u  |  u  |  
    !    --w-----w-- --w--        
    !   |  u  |  u  |  u  |  
    !    --w-----w-- --w-- 
    ! ---------------------------------------------------------------------------
    ! Projection kernel: anisotropic gaussian, oriented along the grid (to be replaced by disk normal kernel)
    use precision
    use dimen
    use control
    use cudafor

    real(fp), parameter :: dang = 2.0_fp*pi/real(n_phi)
    real(fp), dimension(n_turb), parameter :: dr = [(turb_r(idx1)/real(n_r), idx1=1,n_turb)]
    real(fp), dimension(n_r,n_turb), parameter :: r  = reshape([((real(idx2-0.5_fp)*dr(idx1), idx2=1,n_r), idx1=1,n_turb)],(/n_r,n_turb/))
    real(fp), dimension(n_r,n_turb), parameter :: dA = reshape([((r(idx2,idx1)*dang*dr(idx1), idx2=1,n_r), idx1=1,n_turb)],(/n_r,n_turb/))

    real(fp), dimension(n_phi), parameter :: cos_Tang = [(cos(dble(i_phi-1)*dang), i_phi=1,n_phi)]
    real(fp), dimension(n_phi), parameter :: sin_Tang = [(sin(dble(i_phi-1)*dang), i_phi=1,n_phi)]

    integer, parameter :: mask_x = 16
    integer, parameter :: mask_y = 32
    integer, parameter :: mask_z = 32

    integer, parameter :: ker_d_x = 32
    integer, parameter :: ker_d_y = 32
    integer, parameter :: ker_d_z = 16
    
    real(fp), dimension(n_turb), parameter :: dA_tower = [(2.d0*tow_r(i_turb)*dz,i_turb = 1,n_turb)]
    real(fp), dimension(n_turb), parameter :: dA_nacell = [(pi*nac_r(i_turb)**2.d0, i_turb=1,n_turb)]
    ! real(fp), dimension(n_turb), parameter :: turb_i = ((/1.28,2.03,2.78/)/z_i)/dx
    ! real(fp), dimension(n_turb), parameter :: turb_i = ((/2.45,3.2,3.95/)/z_i)/dx
    real(fp), dimension(n_turb), parameter :: turb_i = ((/0.85,1.6,2.35/)/z_i)/dx
    real(fp), dimension(n_turb), parameter :: turb_j = ((/0.8,0.8,0.8/)/z_i)/dy
    ! real(fp), dimension(n_turb), parameter :: turb_j = ((/0.4,0.4,0.4/)/z_i)/dy
    real(fp),parameter :: hub_tower_gap = 0!turb_r(1)/3 ! The gap between the tower and the hub (2 cm for WiRE-01)
    real(fp),parameter :: hub_tower_gap1 = turb_r(1)/3 ! The gap between the tower and the hub (2 cm for WiRE-01)
    contains
    
    Subroutine turbine_force(Fx,Fy,Fz,CTF,power,u,v,w,turb_loc,t)
    !---------------------------------------------------------------------------
    ! declaration
    !---------------------------------------------------------------------------    
        implicit none
        real(fp),dimension(nx,ny,nz2),intent(out),device :: fx,fy,fz
        real(fp),dimension(nx,ny,nz2,2),intent(out),device :: CTF
        real(fp),dimension(n_turb),intent(out),device    :: power
        real(fp),dimension(nx,ny,nz2),intent(in),device :: u,v,w
        real(fp),dimension(n_turb,4),intent(in),device :: turb_loc
        real(fp),dimension(n_turb,4) :: turb_loc_host
        real(fp), dimension(:),allocatable,device :: CTUin,CTU_local,turb_rpm  
        real(fp), dimension(n_turb) :: CTUin_host,mean_CTUin 
        integer :: i,j,k,t,counter
    
        save CTUin,CTU_local,turb_rpm,counter
    !---------------------------------------------------------------------------
    ! code
    !---------------------------------------------------------------------------
        if (t == 1) then
            allocate(CTUin(n_turb))
            allocate(CTU_local(n_turb))
            allocate(turb_rpm(n_turb))
        end if
        fx = 0._fp
        fy = 0._fp
        fz = 0._fp
        power = 0._fp
        !---------------------------------------------------------------------------
        ! compute models
        if(turbine_model == 1)then
            call tower(fx,fy,fz,u,v,w,turb_loc,t) ! Somehow it do more harms than good for power prediction!
            call controller_fix(turb_rpm,CTUin,u,turb_loc,t)
            call nacelle(fx,fy,fz,CTUin,u,v,w,turb_loc,t)
            call admryaw(fx,fy,fz,CTF,power,u,v,w,turb_loc,turb_rpm,CTU_local,t,me,nall)
            if (t>4000) then
                CTUin_host = CTUin
                counter = counter + 1
                mean_CTUin = mean_CTUin + CTUin_host
                print *,mean_CTUin/counter,counter
            end if
        end if
        
    end Subroutine turbine_force

    !===============================================================================
    ! compute ADMR for yaw turbine
    !===============================================================================
    
    Subroutine admryaw(fx,fy,fz,CTF,power,u,v,w,turb_loc,turb_rpm,CTU_local,t,me,nall)
    !----------------------------------------------------------------------------
    ! Declaration
    !----------------------------------------------------------------------------
        use cudafor
        implicit none
        ! Interface variables
        real(fp),dimension(nx,ny,nz2),intent(inout),device :: fx,fy,fz 
        real(fp),dimension(n_phi,n_r,n_turb,2),intent(out),device :: CTF 
        real(fp),dimension(n_turb),intent(out),device      :: power
        real(fp),dimension(nx,ny,nz2),intent(in),device    :: u,v,w     
        real(fp),dimension(n_turb,4),intent(in),device     :: turb_loc 
        real(fp),dimension(n_turb),intent(inout),device    :: turb_rpm,CTU_local
        integer,intent(in)                                 :: t,me,nall
        ! Internal variables
        real(fp),dimension(:,:,:,:,:),allocatable,device   :: coeff       !< Interpoltaion coefficient
        real(fp),dimension(:,:,:,:),allocatable,device     :: sum_ker     !< Normalization for the smearing kernel 
        integer,dimension(:,:,:,:),allocatable,device      :: blade_ijk   !< Closest grid point for a blade element
        ! real(fp),dimension(:,:,:,:),allocatable,device     :: CTF         !< Force on the blade element (CTFx,CTFt)
        ! real(fp),dimension(n_phi,n_r,n_turb,2)     :: CTF_host  
        real(fp),dimension(:,:),allocatable,device         :: twist_angle,solidity
        real(fp),dimension(:,:),allocatable,device         :: turb_aerodyn,turb_geo
        real(fp), dimension(:),allocatable,device          :: radius_dat,twist_dat,chord_dat

        real(fp),dimension(:),allocatable,device            :: turb_rpm_new,torque
        real(fp),dimension(n_turb) :: turb_rpm_host
        real(fp),dimension(:,:),allocatable                :: turb_aerodyn_host,turb_geo_host
        integer :: i,j,k,me_k,index,i_global,hub_node,nlines,io,iter
        ! Cuda variables
        type(dim3) :: grid_be,tBlock_be,grid_full,tBlock_full
        ! kernel config for force computing on blade element
        tBlock_be   = dim3(8,8,1)
        grid_be     = dim3(n_phi/8,n_r/8,n_turb)
        ! kernel config for force prejection on cartesian grid
        tBlock_full = dim3(mask_x,mask_y,1)
        grid_full   = dim3(n_phi,n_r,nzb)
    
        save coeff,blade_ijk,twist_angle,solidity,sum_ker,turb_aerodyn,turb_geo,turb_rpm_new,torque
        !----------------------------------------------------------------------------
        ! code
        !----------------------------------------------------------------------------
        if (t == 1) then
            ! load turbine geometry files
            open(unit=100,file='input/turb_geo.dat')
                nlines = 0
                DO
                    READ(100,*,iostat=io)
                    IF (io/=0) EXIT
                    nlines = nlines + 1
                END DO
            close(100)

            allocate(turb_geo_host(3,nlines))
            allocate(turb_geo(3,nlines))
            allocate(turb_aerodyn_host(3,181))
            allocate(turb_aerodyn(3,181))
            ! Reading twice, any better idea?
            open(unit=101,file='input/turb_geo.dat')
                DO k=1,nlines
                    READ(101,*,iostat=io) turb_geo_host(1:3,k)
                    IF (io/=0) EXIT
                END DO
            close(101)
            turb_geo = turb_geo_host    ! Copy to device

            allocate(radius_dat(nlines))
            allocate(twist_dat(nlines))
            allocate(chord_dat(nlines))

            radius_dat = turb_geo(1,:)
            twist_dat = turb_geo(2,:)
            chord_dat = turb_geo(3,:)

            ! load turbine aerodynamic files (lift and drag)
            if(turb_flag > 0)then
                open(unit=99,file='input/turb_aerodyn.dat')
                do k=1,181
                    read(99,*)turb_aerodyn_host(1:3,k)
                end do
                close(99)
            endif
            turb_aerodyn = turb_aerodyn_host ! Copy to device
            ! device array allocation
            allocate(coeff(n_phi,n_r,n_turb,2,8))
            allocate(sum_ker(n_phi,n_r,n_turb,2))
            allocate(blade_ijk(n_phi,n_r,n_turb,4))
            ! allocate(CTF(n_phi,n_r,n_turb,2))
            allocate(twist_angle(n_r,n_turb))
            allocate(solidity(n_r,n_turb))
            ! allocate(turb_rpm_new(n_turb),torque(n_turb))
            ! Pre-compute the interpolation coefficient on the blade element
            call force_compute_pre_nacelle<<<grid_be,tBlock_be>>>(coeff,blade_ijk,twist_angle,solidity,&
                                                                turb_loc,radius_dat,twist_dat,chord_dat)
            ! Pre-compute smearing parameter on the masked grid
            sum_ker = 0
            call force_projection_pre<<<grid_full,tBlock_full>>>(sum_ker,turb_loc)
        end if
        ! Compute the force on the blade elements
        CTU_local = 0.0

        call force_compute_pre2<<<grid_be,tBlock_be>>>(CTU_local,&
                                                        u,v,w,coeff,blade_ijk,twist_angle,solidity,&
                                                        turb_rpm,turb_loc,turb_aerodyn)

        call force_compute<<<grid_be,tBlock_be>>>(CTF,power,&
                                                    u,v,w,coeff,blade_ijk,twist_angle,solidity,&
                                                    turb_rpm,CTU_local,turb_loc,turb_aerodyn)

        call force_projection<<<grid_full,tBlock_full>>>(fx,fy,fz,CTF,sum_ker,turb_loc)
    end Subroutine admryaw
    
    attributes(global) subroutine force_compute_pre(coeff,blade_ijk,twist_angle,solidity,&
                                                    turb_loc,radius_dat,twist_dat,chord_dat)
    !----------------------------------------------------------------------------
    ! Declaration
    !----------------------------------------------------------------------------
        implicit none
        ! Interface variables
        real(fp),dimension(n_phi,n_r,n_turb,2,8) ,intent(out) :: coeff    
        integer,dimension(n_phi,n_r,n_turb,4),intent(out)     :: blade_ijk
        real(fp),dimension(n_r,n_turb),intent(out)            :: twist_angle,solidity
        real(fp),dimension(n_turb,4),intent(in)               :: turb_loc
        real(fp),dimension(:),intent(in)                      :: radius_dat,twist_dat,chord_dat
        ! Internal variables
        real(fp) :: c_w_1d(8),c_uv_1d(8)
        real(fp) :: blade_ii,blade_jj,blade_kk_uv,blade_kk_w  
        real(fp) :: tmp3,chord_length
        integer  :: i,j,k,i_turb,i_phi,i_r,me_k,nlines
    !----------------------------------------------------------------------------
    ! code
    !----------------------------------------------------------------------------
        ! Index from cuda kernel
        i_phi  = (blockIdx%x - 1) * blockDim%x + threadIdx%x
        i_r    = (blockIdx%y - 1) * blockDim%y + threadIdx%y
        i_turb = (blockIdx%z - 1) * blockDim%z + threadIdx%z

        ! Interpolate Chord length
        call itp1D(radius_dat,chord_dat,size(radius_dat),r(i_r,i_turb)*z_i,chord_length)
        chord_length = chord_length/z_i
        ! Interpolate twist angle
        call itp1D(radius_dat,twist_dat,size(radius_dat),r(i_r,i_turb)*z_i,twist_angle(i_r,i_turb) )
        ! Compute solidity
        solidity(i_r,i_turb) = 3._fp*chord_length/(2._fp*pi*r(i_r,i_turb))
    
        ! blade element centre location
        ! print *,0.7/z_i/dx
        blade_ii    = turb_i(i_turb)-(hub_tower_gap*cos(turb_loc(i_turb,4)))/dx - r(i_r,i_turb)*cos_Tang(i_phi)/dx*sin(turb_loc(i_turb,4))
        blade_jj    = turb_j(i_turb)-(hub_tower_gap*sin(turb_loc(i_turb,4)))/dy + r(i_r,i_turb)*cos_Tang(i_phi)/dy*cos(turb_loc(i_turb,4))
        blade_kk_w  = turb_loc(i_turb,3)/dz + r(i_r,i_turb)*sin_Tang(i_phi)/dz + 2._fp
        blade_kk_uv = blade_kk_w - 0.5_fp

        ! Global index of the left_lower grid to a blade element centre
        blade_ijk(i_phi,i_r,i_turb,1) = int(blade_ii)
        blade_ijk(i_phi,i_r,i_turb,2) = int(blade_jj)
        blade_ijk(i_phi,i_r,i_turb,3) = int(blade_kk_uv)
        blade_ijk(i_phi,i_r,i_turb,4) = int(blade_kk_w)   
        ! Trilinear interpolation coefficients 
        ! NOTICE: Interpolation at o for w node needs to be treated differently
        call get_interp_coeff(c_uv_1d,blade_ii,blade_jj,blade_kk_uv) 
        call get_interp_coeff(c_w_1d,blade_ii,blade_jj,blade_kk_w)
        coeff(i_phi,i_r,i_turb,1,:) = c_uv_1d(:)
        coeff(i_phi,i_r,i_turb,2,:) = c_w_1d(:)

    end subroutine force_compute_pre


    attributes(global) subroutine force_compute_pre2(CTU_local,&
                                                u,v,w,coeff,blade_ijk,twist_angle,solidity,&
                                                turb_rpm,turb_loc,turb_aerodyn)
    !----------------------------------------------------------------------------
    ! Declaration
    !----------------------------------------------------------------------------
    implicit none 
    ! Interface variables
    real(fp),dimension(n_turb),intent(out)              :: CTU_local
    real(fp),dimension(nx,ny,nz2),intent(in)            :: u,v,w
    real(fp),dimension(n_phi,n_r,n_turb,2,8),intent(in) :: coeff 
    integer,dimension(n_phi,n_r,n_turb,4),intent(in)    :: blade_ijk
    real(fp),dimension(n_r,n_turb),intent(in)           :: twist_angle,solidity
    real(fp),dimension(n_turb),intent(in)               :: turb_rpm
    real(fp),dimension(n_turb,4),intent(in)             :: turb_loc
    real(fp),dimension(3,181),intent(in)                :: turb_aerodyn
    ! Internal variables
    real(fp) :: c_w_1d(8),c_uv_1d(8)
    real(fp) :: CTphi,sin_CTphi,cos_CTphi
    real(fp) :: CTU,CTV,CTW,CTUrel,AoA
    real(fp) :: CTCL,CTCD,CTU_origin,CTV_origin,CTW_origin
    real(fp) :: f1_tip,f2_tip,f1_hub,f2_hub,g
    integer :: i_turb,i_phi,i_r,istat
    !----------------------------------------------------------------------------
    ! code
    !----------------------------------------------------------------------------
    ! Index from cuda kernel
    i_phi  = (blockIdx%x - 1) * blockDim%x + threadIdx%x
    i_r    = (blockIdx%y - 1) * blockDim%y + threadIdx%y
    i_turb = (blockIdx%z - 1) * blockDim%z + threadIdx%z

    if (i_r >= n_r_s) then
        ! Get trilinear interpolcation coefficient of the blade element
        c_uv_1d = coeff(i_phi,i_r,i_turb,1,:)
        c_w_1d  = coeff(i_phi,i_r,i_turb,2,:)
        ! Interpolate the velocity at the blade element
        call compute_vel_3D(CTU_origin,u,&
                            blade_ijk(i_phi,i_r,i_turb,1),&
                            blade_ijk(i_phi,i_r,i_turb,2),&
                            blade_ijk(i_phi,i_r,i_turb,3),c_uv_1d)
        call compute_vel_3D(CTV_origin,v,&
                            blade_ijk(i_phi,i_r,i_turb,1),&
                            blade_ijk(i_phi,i_r,i_turb,2),&
                            blade_ijk(i_phi,i_r,i_turb,3),c_uv_1d)
        call compute_vel_3D(CTW_origin,w,&
                            blade_ijk(i_phi,i_r,i_turb,1),&
                            blade_ijk(i_phi,i_r,i_turb,2),&
                            blade_ijk(i_phi,i_r,i_turb,4),c_w_1d)

        ! Project from the original grid-align reference to the disk normal reference 
        CTU = CTU_origin*cos(turb_loc(i_turb,4))+CTV_origin*sin(turb_loc(i_turb,4))
        CTV = CTV_origin*cos(turb_loc(i_turb,4))-CTU_origin*sin(turb_loc(i_turb,4))
        CTW = CTW_origin

        ! ! print *,CTU
        istat = atomicadd(CTU_local(i_turb),CTU*dA(i_r,i_turb)/(pi*(turb_r(i_turb)/8)**2))
        call syncthreads()
    end if
    end subroutine force_compute_pre2
    
    attributes(global) subroutine force_projection_pre(sum_ker,turb_loc)
    !----------------------------------------------------------------------------
    ! Declaration
    !----------------------------------------------------------------------------
        implicit none
        ! Interface variables
        real(fp),dimension(n_phi,n_r,n_turb,2),intent(inout) :: sum_ker
        real(fp),dimension(n_turb,4),intent(in)  :: turb_loc
        ! Internal variables
        real(fp) :: sigma_x,sigma_yz,sigma,tmp1,tmp2,tmp3,ker_u,ker_w    
        real(fp) :: mu_x,mu_y,mu_z
        real(fp) :: coord_x,coord_y,coord_z_u,coord_z_w
        integer :: i,j,k,i_turb,i_phi,i_r,istat, i_global, j_global, k_global
        !----------------------------------------------------------------------------
        ! code
        !----------------------------------------------------------------------------
        ! Index from cuda kernel
        i = threadIdx%x !blockIdx%x 
        j = threadIdx%y !blockIdx%y 
        k = blockIdx%z + 1
        i_phi   = blockIdx%x 
        i_r     = blockIdx%y 
        ! Loop through turbine
        ! TODO: replace by loop through x masking grid?
        do i_turb = 1,n_turb

            if (i_r >= n_r_s) then
                ! Blade element relative coordinates to the hub
                mu_x = - r(i_r,i_turb)*cos_Tang(i_phi)*sin(turb_loc(i_turb,4)) 
                mu_y = r(i_r,i_turb)*cos_Tang(i_phi)*cos(turb_loc(i_turb,4))
                mu_z = r(i_r,i_turb)*sin_Tang(i_phi)                           ! Why +1: z = 2 to nzb+1
   
                ! global index for kernel
                i_global = int(turb_i(i_turb)-(hub_tower_gap*cos(turb_loc(i_turb,4)))/dx) + i - mask_x/2
                j_global = int(turb_j(i_turb)-(hub_tower_gap*sin(turb_loc(i_turb,4)))/dy) + j - mask_y/2
                k_global = k 

                ! Grid coordinates in the hub-centered reference frame
                coord_x = i_global*dx-(turb_i(i_turb)*dx-hub_tower_gap*cos(turb_loc(i_turb,4)))
                coord_y = j_global*dy-(turb_j(i_turb)*dy-hub_tower_gap*sin(turb_loc(i_turb,4)))
                coord_z_u = (k_global-1.5)*dz-turb_loc(i_turb,3)
                coord_z_w = coord_z_u - 0.5*dz

                ! Apply gaussian smoothing kernel
                sigma_x  = sqrt((r(i_r,i_turb)*dang)**2+dr(i_turb)**2)
                sigma_yz = sqrt((r(i_r,i_turb)*dang)**2+dr(i_turb)**2)

                tmp1   = 1._fp/(sigma_yz**2*sigma_x*sqrt(pi)**3)
                tmp2   = -1._fp
                tmp3   = ((coord_x-mu_x)/sigma_x)**2+((coord_y-mu_y)/sigma_yz)**2+((coord_z_u-mu_z)/sigma_yz)**2
                ker_u  = tmp1*exp(tmp2*tmp3)
                tmp3   = ((coord_x-mu_x)/sigma_x)**2+((coord_y-mu_y)/sigma_yz)**2+((coord_z_w-mu_z)/sigma_yz)**2
                ker_w  = tmp1*exp(tmp2*tmp3)

                ! Loop through all kernel grid points to sum the smearing coeff.
                istat = atomicAdd(sum_ker(i_phi,i_r,i_turb,1),ker_u)
                istat = atomicAdd(sum_ker(i_phi,i_r,i_turb,2),ker_w)
            end if
            call syncthreads() 
        end do
    end subroutine force_projection_pre

    attributes(global) subroutine force_compute(CTF,power,&
                                                u,v,w,coeff,blade_ijk,twist_angle,solidity,&
                                                turb_rpm,CTU_local,turb_loc,turb_aerodyn)
    !----------------------------------------------------------------------------
    ! Declaration
    !----------------------------------------------------------------------------
        implicit none 
        ! Interface variables
        real(fp),dimension(n_phi,n_r,n_turb,2),intent(out)  :: CTF
        real(fp),dimension(n_turb),intent(out)              :: power
        real(fp),dimension(nx,ny,nz2),intent(in)            :: u,v,w
        real(fp),dimension(n_phi,n_r,n_turb,2,8),intent(in) :: coeff 
        integer,dimension(n_phi,n_r,n_turb,4),intent(in)    :: blade_ijk
        real(fp),dimension(n_r,n_turb),intent(in)           :: twist_angle,solidity
        real(fp),dimension(n_turb),intent(in)               :: turb_rpm,CTU_local
        real(fp),dimension(n_turb,4),intent(in)             :: turb_loc
        real(fp),dimension(3,181),intent(in)                :: turb_aerodyn
        ! Internal variables
        real(fp) :: c_w_1d(8),c_uv_1d(8)
        real(fp) :: CTphi,sin_CTphi,cos_CTphi
        real(fp) :: CTU,CTV,CTW,CTUrel,AoA
        real(fp) :: CTCL,CTCD,CTU_origin,CTV_origin,CTW_origin
        real(fp) :: f1_tip,f2_tip,f1_hub,f2_hub,g
        integer :: i_turb,i_phi,i_r,istat
    !----------------------------------------------------------------------------
    ! code
    !----------------------------------------------------------------------------
        ! Index from cuda kernel
        i_phi  = (blockIdx%x - 1) * blockDim%x + threadIdx%x
        i_r    = (blockIdx%y - 1) * blockDim%y + threadIdx%y
        i_turb = (blockIdx%z - 1) * blockDim%z + threadIdx%z
    
        if (i_r >= n_r_s) then
            ! Get trilinear interpolcation coefficient of the blade element
            c_uv_1d = coeff(i_phi,i_r,i_turb,1,:)
            c_w_1d  = coeff(i_phi,i_r,i_turb,2,:)
            
            ! Interpolate the velocity at the blade element
            call compute_vel_3D(CTU_origin,u,&
                                blade_ijk(i_phi,i_r,i_turb,1),&
                                blade_ijk(i_phi,i_r,i_turb,2),&
                                blade_ijk(i_phi,i_r,i_turb,3),c_uv_1d)
            call compute_vel_3D(CTV_origin,v,&
                                blade_ijk(i_phi,i_r,i_turb,1),&
                                blade_ijk(i_phi,i_r,i_turb,2),&
                                blade_ijk(i_phi,i_r,i_turb,3),c_uv_1d)
            call compute_vel_3D(CTW_origin,w,&
                                blade_ijk(i_phi,i_r,i_turb,1),&
                                blade_ijk(i_phi,i_r,i_turb,2),&
                                blade_ijk(i_phi,i_r,i_turb,4),c_w_1d)
            
            ! Project from the original grid-align reference to the disk normal reference 
            CTU = CTU_origin*cos(turb_loc(i_turb,4))+CTV_origin*sin(turb_loc(i_turb,4))
            CTV = CTV_origin*cos(turb_loc(i_turb,4))-CTU_origin*sin(turb_loc(i_turb,4))
            CTW = CTW_origin
            ! Compute the tangential velocity relative to the rotating blade                   
            ! CTV = CTW*cos_Tang(i_phi)-CTV*sin_Tang(i_phi) + turb_rpm(i_turb)/60*2*pi*(r(i_r,i_turb)*z_i)

            ! ! print *,CTU
            ! ! Find the attack angle and relative inflow velocity for the blade element
            ! CTphi = atan(CTU/CTV)
            ! sin_CTphi = sin(CTphi)
            ! cos_CTphi = cos(CTphi)
            ! ! Convert to degree
            ! AoA = CTphi*rad2deg-twist_angle(i_r,i_turb)
            ! CTUrel  = CTU/sin_CTphi

            ! ! compute cl/cd from AoA (assume one Re)
            ! if (AoA < -90._fp) then
            !     AoA = -90._fp
            ! elseif (AoA > 90._fp) then
            !     AoA = 90._fp
            ! endif
            ! call compute_cl_cd(CTCL,CTCD,AOA,turb_aerodyn)
            
            ! Tip loss factor correction
            ! f1_tip = 3._fp*(turb_r(i_turb)-r(i_r,i_turb))/(2.0*r(i_r,i_turb)*sin_CTphi)
            ! g      = 1.0!exp(-0.125*(3*tsp-21))+0.1
            ! f2_tip = 2._fp/pi*acos(exp(-g*f1_tip))
            ! ! Hub loss factor correction
            ! f1_hub = 3._fp*(r(i_r,i_turb)-nac_r(i_turb))/(2.0*r(i_r,i_turb)*sin_CTphi)
            ! f2_hub = 2._fp/pi*acos(exp(-g*f1_hub))
            ! Impose a stronger restriction: necessary for yawed turbine
            ! Basically igore the case with weird AoA
            ! if (AoA > -10 .and. AoA < 50) then 
                ! Normal force
                CTF(i_phi,i_r,i_turb,1) = 0.5_fp*CTU_local(i_turb)**2*1.45*dA(i_r,i_turb)/(dx*dy*dz)
                ! Tangential force
                CTF(i_phi,i_r,i_turb,2) = 0
                                        !0.5_fp*(CTUrel**2)*solidity(i_r,i_turb)&
                                        !*dA(i_r,i_turb)/(dx*dy*dz)&
                                        !*(CTCL*sin_CTphi-CTCD*cos_CTphi)*f2_tip*f2_hub
            ! end if

            call syncthreads() 
        end if
    end subroutine force_compute
      
    attributes(global) subroutine force_projection(fx,fy,fz,CTF,sum_ker,turb_loc)
    !----------------------------------------------------------------------------
    ! Declaration
    !----------------------------------------------------------------------------
        implicit none
        ! Interface variables
        real(fp),dimension(nx,ny,nz2),intent(inout)       :: Fx,Fy,Fz
        real(fp),dimension(n_phi,n_r,n_turb,2),intent(in) :: CTF,sum_ker
        real(fp),dimension(n_turb,4),intent(in)           :: turb_loc
        ! Internal variables
        real(fp) :: sin_CTangx,cos_CTangz  
        real(fp) :: sigma,sigma_x,sigma_yz,tmp1,tmp2,tmp3
        real(fp) :: ker_u,ker_w
        real(fp) :: coord_x,coord_y,coord_z_u,coord_z_w,r_u,r_w
        real(fp) :: angle_uv,angle_z
        real(fp) :: mu_x,mu_y,mu_z
        real(fp) :: CTFy,CTFx_origin,CTFy_origin,CTFz_origin
        real(fp) :: CTx,CTy,CTzu,CTzw
        integer :: i,j,k,i_turb,i_phi,i_r,i_global,j_global,k_global,istat
    !----------------------------------------------------------------------------
    ! code
    !----------------------------------------------------------------------------
        ! Index from cuda kernel
        i = threadIdx%x !blockIdx%x 
        j = threadIdx%y !blockIdx%y 
        k = blockIdx%z + 1
        i_phi   = blockIdx%x 
        i_r     = blockIdx%y 

        do i_turb = 1,n_turb
            if (i_r >= n_r_s) then
                mu_x = -r(i_r,i_turb)*cos_Tang(i_phi)*sin(turb_loc(i_turb,4)) 
                mu_y =  r(i_r,i_turb)*cos_Tang(i_phi)*cos(turb_loc(i_turb,4))
                mu_z =  r(i_r,i_turb)*sin_Tang(i_phi)

                ! global index for kernel
                i_global = int(turb_i(i_turb)-(hub_tower_gap*cos(turb_loc(i_turb,4)))/dx) + i - mask_x/2
                j_global = int(turb_j(i_turb)-(hub_tower_gap*sin(turb_loc(i_turb,4)))/dy) + j - mask_y/2
                k_global = k 

                ! Grid coordinates in the hub-centered reference frame
                coord_x = i_global*dx-(turb_i(i_turb)*dx-hub_tower_gap*cos(turb_loc(i_turb,4)))
                coord_y = j_global*dy-(turb_j(i_turb)*dy-hub_tower_gap*sin(turb_loc(i_turb,4)))
                coord_z_u = (k_global-1.5)*dz-turb_loc(i_turb,3)
                coord_z_w = coord_z_u - 0.5*dz

                ! Distance to the hub
                ! r_u  = sqrt(((coord_y+coord_x*tan(turb_loc(i_turb,4)))*cos(turb_loc(i_turb,4)))**2 + coord_z_u**2)
                ! r_w  = sqrt(((coord_y+coord_x*tan(turb_loc(i_turb,4)))*cos(turb_loc(i_turb,4)))**2 + coord_z_w**2)

                r_u  = sqrt((coord_y/cos(turb_loc(i_turb,4)))**2 + coord_z_u**2)
                r_w  = sqrt((coord_y/cos(turb_loc(i_turb,4)))**2 + coord_z_w**2)
                ! Phase angle of the grid point
                sin_CTangx = coord_z_u/(r_u+1e-16)
                ! cos_CTangz = ((coord_y+coord_x*tan(turb_loc(i_turb,4)))*cos(turb_loc(i_turb,4)))/(r_w+1e-16)
                cos_CTangz = ((coord_y)/cos(turb_loc(i_turb,4)))/(r_w+1e-16)

                sigma_x  = sqrt((r(i_r,i_turb)*dang)**2+dr(i_turb)**2)
                sigma_yz = sqrt((r(i_r,i_turb)*dang)**2+dr(i_turb)**2)

                tmp1   = 1._fp/(sigma_yz**2*sigma_x*sqrt(pi)**3)
                tmp2   = -1._fp

                tmp3   = ((coord_x-mu_x)/sigma_x)**2+((coord_y-mu_y)/sigma_yz)**2+((coord_z_u-mu_z)/sigma_yz)**2
                ker_u  = tmp1*exp(tmp2*tmp3)/sum_ker(i_phi,i_r,i_turb,1)
                tmp3   = ((coord_x-mu_x)/sigma_x)**2+((coord_y-mu_y)/sigma_yz)**2+((coord_z_u-mu_z-0.5*dz)/sigma_yz)**2
                ker_w  = tmp1*exp(tmp2*tmp3)/sum_ker(i_phi,i_r,i_turb,2)

                ! Rotate the force from the disk-normal reference to the original reference
                CTFy        = CTF(i_phi,i_r,i_turb,2)*sin_CTangx
                CTFx_origin = CTF(i_phi,i_r,i_turb,1)*cos(turb_loc(i_turb,4))-CTFy*sin(turb_loc(i_turb,4))
                CTFy_origin = CTF(i_phi,i_r,i_turb,1)*sin(turb_loc(i_turb,4))+CTFy*cos(turb_loc(i_turb,4))
                CTFz_origin = - CTF(i_phi,i_r,i_turb,2)*cos_CTangz
                ! Project the force
                istat = atomicAdd(Fx(i_global,j_global,k_global),CTFx_origin*ker_u)
                istat = atomicAdd(Fy(i_global,j_global,k_global),CTFy_origin*ker_u)
                istat = atomicAdd(Fz(i_global,j_global,k_global),CTFz_origin*ker_w)
            end if
            call syncthreads() 
        end do
    
    end subroutine force_projection

    attributes(device) subroutine get_interp_coeff(c,blade_ii,blade_jj,blade_kk)
        implicit none
        real(fp),dimension(8),intent(out) :: c
        real(fp),intent(in) :: blade_ii,blade_jj,blade_kk
        real(fp),dimension(3) :: blade_point
        integer :: i,j,k,counter
        real(fp),dimension(3,2) :: l
    
        blade_point = (/blade_ii,blade_jj,blade_kk/)
        ! Get the location in the cube 
        do i = 1,3
            l(i,1) = 1._fp-(dble(blade_point(i)-int(blade_point(i))))
            l(i,2) = dble(blade_point(i)-int(blade_point(i)))
            ! if (i == 1) print *,i,l(i,1),l(i,2)
        end do
        
            ! Get the coefficient
        counter = 1
        do i = 1,2
            do j = 1,2
                do k = 1,2
                    c(counter) = l(1,i)*l(2,j)*l(3,k)
                    counter = counter + 1                 
                end do
            end do
        end do 
    
    end subroutine get_interp_coeff
    
    attributes(device) subroutine compute_vel_3D(u_interp,u,blade_i,blade_j,blade_k,c)
        implicit none
    
        real(fp),intent(out) :: u_interp
        real(fp),dimension(nx,ny,nz2),intent(in) :: u
        integer,intent(in) :: blade_i,blade_j,blade_k
        integer :: i,j,k,counter
        real(fp),dimension(8),intent(in) :: c
    
        ! To be rewritten using dot_product
        counter = 1
        u_interp = 0
        do i = 0,1
            do j = 0,1
                do k = 0,1
                    u_interp = u_interp + c(counter) * u(blade_i+i,blade_j+j,blade_k+k)   
                    counter = counter + 1             
                end do
            end do
        end do 
    
    end subroutine compute_vel_3D
    
    attributes(device) subroutine compute_cl_cd(CTCL,CTCD,x,turb_aerodyn)
        implicit none
        real(fp) x,compute_cl,CTCL,CTCD
        real(fp),dimension(3,181) :: turb_aerodyn
        integer  i,j
    
        i=floor(x)+91
        j=ceiling(x)+91
        CTCL = dble(x-floor(x))*turb_aerodyn(2,j)+dble(ceiling(x)-x)*turb_aerodyn(2,i)
        CTCD = dble(x-floor(x))*turb_aerodyn(3,j)+dble(ceiling(x)-x)*turb_aerodyn(3,i)
    end subroutine compute_cl_cd
    
    attributes(device) subroutine itp1D(xData,yData,array_size,xVal,yVal)
        implicit none
        integer,intent(in) :: array_size
        real(fp),intent(in) :: xData(array_size),yData(array_size)
        real(fp),intent(in) :: xVal
        real(fp),intent(out) :: yVal
        integer ::  dataIndex
        real(fp) :: minXdata,maxXdata,xRange,weight
    
        minXData = xData(1)
        maxXData = xData(size(xData))
    
        if (xVal<minXData .or. xVal>maxXData) then
            print *,"Error in interpolation"
            stop
        else
            do dataIndex = 1,array_size-1
                if (xVal>xData(dataIndex) .and. xVal<xData(dataIndex+1)) then
                    weight = (xVal-xData(dataIndex))/(xData(dataIndex+1)-xData(dataIndex))
                    yVal = (1._fp-weight)*yData(dataIndex) + weight*yData(dataIndex+1)
                    exit
                end if
            end do
        end if
    
    end subroutine itp1D
    
end module turbine